<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drop Upload</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <div class="file-list-section">
        <h2>
            <span id="pageTitle"></span> (<span id="retainTime"></span>)
            <div class="lang-switch">
                <button id="langZh" class="lang-btn">ä¸­</button>
                <button id="langEn" class="lang-btn">EN</button>
            </div>
        </h2>
        <div class="controls">
            <div id="dropZone" class="drop-zone">
                <p id="dropZoneText"></p>
                <p id="dropZoneHint" class="drop-hint"></p>
                <input type="file" id="fileInput" style="display: none;" />
            </div>
        </div>
        <div id="uploadStatus" class="upload-status"></div>
        <div id="fileList" class="file-list"></div>
    </div>
    <div id="dialog">
        <div class="dialog-overlay"></div>
        <div class="dialog">
            <span>Access Key:</span>
            <input type="text" id="accessKeyInput" />
            <button id="dialogSubmit" type="button"></button>
        </div>
    </div>
    <script>
        const language = navigator.language || 'zh-TW';
        const supportedLanguages = ['zh-TW', 'en'];
        let currentLang = supportedLanguages.includes(language) ? language : 'zh-TW';
        const textId = {
            'title': 'title',
            'retainTime': 'retainTime',
            'dropZoneText': 'dropZoneText',
            'dropZoneHint': 'dropZoneHint',
            'accessKeyPlaceholder': 'accessKeyPlaceholder',
            'connectBtn': 'connectBtn',
            'fileNameHeader': 'fileNameHeader',
            'sizeHeader': 'sizeHeader',
            'uploadTimeHeader': 'uploadTimeHeader',
            'countdownHeader': 'countdownHeader',
            'deleteTitle': 'deleteTitle',
            'expiring': 'expiring',
            'noFiles': 'noFiles',
            'loadingFiles': 'loadingFiles',
            'loadFilesError': 'loadFilesError',
            'uploading': 'uploading',
            'uploadSuccess': 'uploadSuccess',
            'uploadError': 'uploadError',
            'uploadChunkError': 'uploadChunkError',
            'deleteSuccess': 'deleteSuccess',
            'deleteError': 'deleteError',
            'sseRetryFailed': 'sseRetryFailed',
            'enterAccessKey': 'enterAccessKey',
            'invalidAccessKey': 'invalidAccessKey',
            'authFailed': 'authFailed',
            'unknownError': 'unknownError'
        };

        const multiLangDictionary = {
            'zh-TW': {
                [textId.title]: 'æš«æ™‚æª”æ¡ˆäº¤æ›å€',
                [textId.retainTime]: 'ä¿ç•™ {0} ç§’',
                [textId.dropZoneText]: 'ðŸ“ æ‹–æ”¾æª”æ¡ˆåˆ°é€™è£¡ä¸Šå‚³',
                [textId.dropZoneHint]: 'æˆ–é»žæ“Šé¸æ“‡æª”æ¡ˆ',
                [textId.accessKeyPlaceholder]: 'è«‹è¼¸å…¥ Access Key',
                [textId.connectBtn]: 'é€£ç·š',
                [textId.fileNameHeader]: 'æª”æ¡ˆåç¨±',
                [textId.sizeHeader]: 'å¤§å°',
                [textId.uploadTimeHeader]: 'ä¸Šå‚³æ™‚é–“',
                [textId.countdownHeader]: 'åˆªé™¤å€’æ•¸',
                [textId.deleteTitle]: 'åˆªé™¤æª”æ¡ˆ',
                [textId.expiring]: 'å³å°‡åˆªé™¤',
                [textId.noFiles]: 'ç›®å‰æ²’æœ‰æª”æ¡ˆ',
                [textId.loadingFiles]: 'è¼‰å…¥ä¸­...',
                [textId.loadFilesError]: 'è¼‰å…¥æª”æ¡ˆæ¸…å–®å¤±æ•—: {0}',
                [textId.uploading]: 'ä¸Šå‚³ä¸­: {0} ({1}%)',
                [textId.uploadSuccess]: 'ä¸Šå‚³æˆåŠŸ: {0} ({1})',
                [textId.uploadError]: 'ä¸Šå‚³å¤±æ•—: {0}',
                [textId.uploadChunkError]: 'ä¸Šå‚³å¤±æ•— (chunk {0}/{1}): {2}',
                [textId.deleteSuccess]: 'å·²åˆªé™¤: {0}',
                [textId.deleteError]: 'åˆªé™¤å¤±æ•—: {0}',
                [textId.sseRetryFailed]: 'SSE é‡æ–°é€£ç·šå¤±æ•—ï¼Œåœæ­¢ä½œæ¥­',
                [textId.enterAccessKey]: 'è«‹è¼¸å…¥ Access Key',
                [textId.invalidAccessKey]: 'Access Key ç„¡æ•ˆï¼Œè«‹å†è©¦ä¸€æ¬¡',
                [textId.authFailed]: 'é©—è­‰å¤±æ•—: {0}',
                [textId.unknownError]: 'æœªçŸ¥éŒ¯èª¤'
            },
            'en': {
                [textId.title]: 'Temporary File Exchange',
                [textId.retainTime]: 'Retain {0} sec',
                [textId.dropZoneText]: 'ðŸ“ Drop files here to upload',
                [textId.dropZoneHint]: 'or click to select files',
                [textId.accessKeyPlaceholder]: 'Enter Access Key',
                [textId.connectBtn]: 'Connect',
                [textId.fileNameHeader]: 'File Name',
                [textId.sizeHeader]: 'Size',
                [textId.uploadTimeHeader]: 'Upload Time',
                [textId.countdownHeader]: 'Expires In',
                [textId.deleteTitle]: 'Delete file',
                [textId.expiring]: 'Expiring',
                [textId.noFiles]: 'No files available',
                [textId.loadingFiles]: 'Loading...',
                [textId.loadFilesError]: 'Failed to load file list: {0}',
                [textId.uploading]: 'Uploading: {0} ({1}%)',
                [textId.uploadSuccess]: 'Upload successful: {0} ({1})',
                [textId.uploadError]: 'Upload failed: {0}',
                [textId.uploadChunkError]: 'Upload failed (chunk {0}/{1}): {2}',
                [textId.deleteSuccess]: 'Deleted: {0}',
                [textId.deleteError]: 'Delete failed: {0}',
                [textId.sseRetryFailed]: 'SSE reconnection failed, stopping',
                [textId.enterAccessKey]: 'Please enter an Access Key',
                [textId.invalidAccessKey]: 'Invalid Access Key, please try again',
                [textId.authFailed]: 'Authentication failed: {0}',
                [textId.unknownError]: 'Unknown error'
            }
        };

        function getText(id, ...args) {
            let template = multiLangDictionary[currentLang][id] || '';
            args.forEach((arg, index) => {
                template = template.replace(`{${index}}`, arg);
            });
            return template;
        }

        function applyLanguage() {
            document.getElementById('pageTitle').textContent = getText(textId.title);
            document.getElementById('dropZoneText').textContent = getText(textId.dropZoneText);
            document.getElementById('dropZoneHint').textContent = getText(textId.dropZoneHint);
            document.getElementById('accessKeyInput').placeholder = getText(textId.accessKeyPlaceholder);
            document.getElementById('dialogSubmit').textContent = getText(textId.connectBtn);
            document.getElementById('retainTime').textContent = getText(textId.retainTime, expireSeconds);
            document.getElementById('langZh').classList.toggle('active', currentLang === 'zh-TW');
            document.getElementById('langEn').classList.toggle('active', currentLang === 'en');
            loadFiles();
        }

        document.getElementById('langZh').addEventListener('click', () => {
            currentLang = 'zh-TW';
            applyLanguage();
        });
        document.getElementById('langEn').addEventListener('click', () => {
            currentLang = 'en';
            applyLanguage();
        });
    </script>

    <script>
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const uploadStatus = document.getElementById('uploadStatus');
        
        let expireSeconds = 60; // é è¨­å€¼
        let countdownInterval = null;

        // é©—è­‰ Access Key
        async function submitAccessKey() {
            const key = document.getElementById('accessKeyInput').value.trim();
            if (!key) {
                alert(getText(textId.enterAccessKey));
                return;
            }
            
            const formData = new FormData();
            formData.append('key', key);
            
            try {
                const authResponse = await fetch('auth', {
                    method: 'POST',
                    body: formData
                });
                
                if (authResponse.ok) {
                    document.getElementById('dialog').classList.remove('show');
                    loadSettings();
                    connectSSE();
                } else {
                    alert(getText(textId.invalidAccessKey));
                }
            } catch (error) {
                alert(getText(textId.authFailed, error.message));
            }
        }

        // ç¶å®šæŒ‰éˆ•äº‹ä»¶
        document.getElementById('dialogSubmit').addEventListener('click', submitAccessKey);
        document.getElementById('accessKeyInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                submitAccessKey();
            }
        });

        // æª¢æŸ¥æ˜¯å¦å·²èªè­‰
        async function checkAuth() {
            try {
                const response = await fetch('settings');
                if (response.status === 401 || response.status === 403) {
                    document.getElementById('dialog').classList.add('show');
                    return false;
                }
                return true;
            } catch (error) {
                console.error('Authentication check failed:', error);
                return false;
            }
        }

        // è¼‰å…¥è¨­å®š
        async function loadSettings() {
            try {
                const response = await fetch('settings');
                if (response.status === 401 || response.status === 403) {
                    return;
                }
                const settings = await response.json();
                expireSeconds = settings.expireSeconds;
                document.getElementById('retainTime').textContent = getText(textId.retainTime, expireSeconds);
            } catch (error) {
                console.error('Failed to load settings:', error);
            }
        }
        
        // åˆå§‹åŒ–
        (async () => {
            applyLanguage();
            if (await checkAuth()) {
                loadSettings();
                connectSSE();
            }
        })();

        // Server-Sent Events (SSE) é€£ç·š
        let eventSource = null;
        let retryCount = 0;
        
        function connectSSE() {
            eventSource = new EventSource('events');
            
            eventSource.addEventListener('connected', (e) => {
                // console.log('SSE å·²é€£ç·š');
                retryCount = 0;
                loadFiles();
            });
            
            eventSource.addEventListener('fileUploaded', (e) => {
                const data = JSON.parse(e.data);
                // console.log('æª”æ¡ˆå·²ä¸Šå‚³:', data.fileName);
                loadFiles();
            });
            
            eventSource.addEventListener('fileDeleted', (e) => {
                const data = JSON.parse(e.data);
                // console.log('æª”æ¡ˆå·²åˆªé™¤:', data.fileName);
                loadFiles();
            });
            
            eventSource.addEventListener('filesCleanedUp', (e) => {
                const data = JSON.parse(e.data);
                // console.log('å·²æ¸…ç†éŽæœŸæª”æ¡ˆ:', data.count, 'å€‹');
                loadFiles();
            });

            eventSource.onerror = (e) => {
                // console.log(`SSE é€£ç·šéŒ¯èª¤ï¼Œå˜—è©¦é‡æ–°é€£ç·š...(${retryCount})`);
                eventSource.close();
                retryCount++;
                if (retryCount >= 5) {
                    showStatus('error', getText(textId.sseRetryFailed));
                    return;
                }
                setTimeout(connectSSE, 3000);
            };
        }

        function showStatus(type, message, autoClear = false) {
            const classes = {
                uploading: 'uploading',
                success: 'success',
                error: 'error-message'
            };
            const icons = {
                uploading: '',
                success: 'âœ“ ',
                error: 'âœ— '
            };
            
            uploadStatus.innerHTML = `<p class="${classes[type]}">${icons[type]}${message}</p>`;
            
            if (autoClear) {
                setTimeout(() => uploadStatus.innerHTML = '', 3000);
            }
        }

        // Drag and drop handlers
        dropZone.addEventListener('click', () => fileInput.click());

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', async (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                await uploadFile(files[0]);
            }
        });

        fileInput.addEventListener('change', async (e) => {
            if (e.target.files.length > 0) {
                await uploadFile(e.target.files[0]);
                fileInput.value = '';
            }
        });

        async function uploadFile(file) {
            const CHUNK_SIZE = 1 * 1024 * 1024; // 1 MB per chunk
            const totalChunks = Math.max(1, Math.ceil(file.size / CHUNK_SIZE));
            const uploadId = generateUUID();

            showStatus('uploading', getText(textId.uploading, escapeHtml(file.name), 0));

            try {
                for (let i = 0; i < totalChunks; i++) {
                    const start = i * CHUNK_SIZE;
                    const end = Math.min(start + CHUNK_SIZE, file.size);
                    const chunk = file.slice(start, end);

                    const formData = new FormData();
                    formData.append('file', chunk);
                    formData.append('fileName', file.name);
                    formData.append('uploadId', uploadId);
                    formData.append('chunkIndex', i);
                    formData.append('totalChunks', totalChunks);

                    const response = await fetch('upload-chunk', {
                        method: 'POST',
                        body: formData
                    });

                    const result = await response.json();

                    if (!response.ok || !result.success) {
                        showStatus('error', getText(textId.uploadChunkError, i + 1, totalChunks, escapeHtml(result.error || getText(textId.unknownError))));
                        return;
                    }

                    const percent = Math.round(((i + 1) / totalChunks) * 100);
                    showStatus('uploading', getText(textId.uploading, escapeHtml(file.name), percent));

                    if (result.complete) {
                        showStatus('success', getText(textId.uploadSuccess, escapeHtml(result.fileName), formatFileSize(result.size)), true);
                        loadFiles();
                    }
                }
            } catch (error) {
                showStatus('error', getText(textId.uploadError, escapeHtml(error.message)));
            }
        }

        async function deleteFile(encodedName, displayName) {
            try {
                const response = await fetch(`delete/?f=${encodedName}`, {
                    method: 'POST'
                });

                const result = await response.json();

                if (response.ok && result.success) {
                    showStatus('success', getText(textId.deleteSuccess, escapeHtml(result.fileName)), true);
                    loadFiles();
                } else {
                    showStatus('error', getText(textId.deleteError, escapeHtml(result.error || getText(textId.unknownError))));
                }
            } catch (error) {
                showStatus('error', getText(textId.deleteError, escapeHtml(error.message)));
            }
        }

        async function loadFiles() {
            try {
                const response = await fetch('files');
                const data = await response.json();
                const fileListDiv = document.getElementById('fileList');
                
                if (data.files.length === 0) {
                    fileListDiv.innerHTML = `<p class="empty-message">${getText(textId.noFiles)}</p>`;
                    if (countdownInterval) {
                        clearInterval(countdownInterval);
                        countdownInterval = null;
                    }
                    return;
                }
                
                let html = `<table><thead><tr><th>${getText(textId.fileNameHeader)}</th><th>${getText(textId.sizeHeader)}</th><th>${getText(textId.uploadTimeHeader)}</th><th>${getText(textId.countdownHeader)}</th></tr></thead><tbody>`;
                data.files.forEach(file => {
                    const size = formatFileSize(file.size);
                    const uploadDate = new Date(file.modified);
                    const dateStr = uploadDate.toLocaleString('zh-TW');
                    const encodedName = encodeURIComponent(file.name);
                    const uploadTime = uploadDate.getTime();
                    
                    html += `<tr data-upload-time="${uploadTime}">
                        <td>
                            <a href="download/?f=${encodedName}" class="file-link" download>${escapeHtml(file.name)}</a>
                            <span class="delete-x" onclick="deleteFile('${encodedName}', '${escapeHtml(file.name).replace(/'/g, "\\'")}')" title="${getText(textId.deleteTitle)}">âœ–</span>
                        </td>
                        <td>${size}</td>
                        <td>${dateStr}</td>
                        <td class="countdown" data-upload-time="${uploadTime}"></td>
                    </tr>`;
                });
                html += '</tbody></table>';
                fileListDiv.innerHTML = html;
                
                // Start countdown updates
                updateCountdowns();
                if (!countdownInterval) {
                    countdownInterval = setInterval(updateCountdowns, 1000);
                }
            } catch (error) {
                document.getElementById('fileList').innerHTML =
                    `<p class="error-message">${getText(textId.loadFilesError, error.message)}</p>`;
            }
        }
        
        function updateCountdowns() {
            const countdownCells = document.querySelectorAll('.countdown');
            const now = Date.now();
            
            countdownCells.forEach(cell => {
                const uploadTime = parseInt(cell.dataset.uploadTime);
                const elapsedSeconds = Math.floor((now - uploadTime) / 1000);
                const remainingSeconds = expireSeconds - elapsedSeconds;
                
                if (remainingSeconds > 0) {
                    cell.textContent = formatCountdown(remainingSeconds);
                    cell.className = 'countdown';
                    
                    if (remainingSeconds < 30) {
                        cell.classList.add('countdown-urgent');
                    } else if (remainingSeconds < 60) {
                        cell.classList.add('countdown-warning');
                    }
                } else {
                    cell.textContent = getText(textId.expiring);
                    cell.className = 'countdown countdown-expired';
                }
            });
        }
        
        function formatCountdown(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function generateUUID() {
            // crypto.randomUUID() is only available in secure contexts (HTTPS) or localhost
            // Fall back to crypto.getRandomValues() which works over HTTP as well.
            if (typeof crypto.randomUUID === 'function') {
                return crypto.randomUUID();
            }
            return '10000000-1000-4000-8000-100000000000'.replace(/[018]/g, c =>
                (+c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> +c / 4).toString(16)
            );
        }
    </script>
</body>
</html>
